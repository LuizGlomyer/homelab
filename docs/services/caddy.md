# Caddy

Check the [Caddyfile](/ansible/roles/services/caddy/templates/edge.Caddyfile.j2).

Caddy acts as a reverse proxy to my homelab setup. There are some strategies to issue certificates, currently I'm using Caddy on Raspberry Pi as a TLS terminator, then it connects securely with mTLS as a client to the Caddy instance running on my Services VM. On the network's edge (Raspberry Pi), I'm using Let's Encrypt to issue certificates for my own domain (glomyer.dev) with the use of DNS-01 challenges. Caddy has plugins that automate this for some DNS providers, such as Cloudflare. I'm also using self-signed certificates from Caddy's CA as a fallback option. In this case every browser/OS will need to install the root certificate generated by Caddy to guarantee a trusted SSL connection.


```bash
# Check installed plugins
/usr/bin/caddy list-modules | grep dns
# See caddy service's logs
journalctl -u caddy -f
```

Some services, such as Portainer, use self-signed certs that cannot be easily verified, so a certain Caddy option (tls_insecure_skip_verify) is needed. It is not the ideal solution, but as these services run on localhost this is reasonable and safe for internal LAN use.

Each domain requires two DNS challenges. This happens because wildcard certs don’t cover the apex/root domain. Therefore, Caddy will request wildcard + apex certificates when needed.

## Cloudflare DNS

Just create a wildcard record (_*.domain.tld_) pointing to your local IP (192.168.0.X). The Cloudflare Proxy option must be disabled as well. 

## Duck DNS

Duck DNS is a free DNS provider, basically you can claim a subdomain from .duckdns.org and point it wherever you like, like the local IP of my Raspberry. I've seen some videos with it working just fine and decided give it a try, but as a free service it comes with some headaches.

![DNS replication](/docs/images/caddy/dns_replication.png)

Some of my subdomains simply do not work. I think it's because the challenge is not being replicated by Duck DNS to the authoritative servers. I gave it some time (talking about weeks) and now it is working fine. However, I got downtime episodes. It is a free service, so it's not that much reliable at all times, therefore I've chose to ditch it.


# How are certificates validated 

Just a little guide for quick reference.

- **Caddy** is the client: it requests, renews, and installs the certificate.
- **Let’s Encrypt** is the certificate authority: it issues the certs.
- **Cloudflare/DuckDNS** provide DNS APIs: they help Caddy prove domain ownership.


## HTTP-01 Challenge

How it works:

1. The CA (e.g., Let’s Encrypt) tells you: “Please place this special file with this token at http://yourdomain.com/.well-known/acme-challenge/...”.
2. The CA then makes an HTTP request to that exact URL.
3. If it finds the expected token, it knows that the server at yourdomain.com is under your control.
4. Certificate is issued.

Requirements:

- Your domain must resolve to a public IP.
- Port 80 (HTTP) must be open and reachable from the internet.


## DNS-01 Challenge

How it works:

1. The CA says: “Please create a TXT record in your DNS: _acme-challenge.yourdomain.com with this token.”
2. The CA queries your domain’s authoritative DNS server for that TXT record.
3. If the record matches, it proves you control the domain.
4. Certificate is issued.

Requirements:

- You must be able to create/edit DNS records for your domain.
- Usually done via your DNS provider’s API (Caddy, Certbot, etc. use plugins like dns.duckdns, dns.cloudflare, etc. to automate this).

Pros:

- Doesn’t require your server to be exposed on port 80 or 443.
- Works with domains that are behind NAT, VPN, firewalls, or reverse proxies.
- Lets you issue wildcard certificates (e.g., *.example.com), which HTTP-01 cannot do.

Cons:

- Slightly more complex: needs DNS provider integration or manual TXT record creation.

# mTLS

This one was tough to pull off but was well worth it. I had to install Caddy to the VM that runs my services as well, the Raspberry Pi in this case acts as a client.

## Explanation

Mutual TLS (mTLS) is standard TLS plus client authentication:

- The server proves its identity to the client (normal TLS)
- The client also proves its identity to the server using a certificate
- Both identities are validated against a trusted Certificate Authority (CA)


### CA certificate (public, shared)

Purpose: trust anchor. Used to verify:
- server certificates (by clients)
- client certificates (by servers)

### Server certificate + key (private to server)

Identity: “I am dashy.internal.glomyer.dev”. Used by:
- Services Caddy only

➡ Example: services-server.crt, services-server.key


### Client certificate + key (private to client)
Identity: “I am the Raspberry”. Used by:
- Raspberry Caddy only

➡ Example: raspberry-client.crt, raspberry-client.key

## Certificate generation

The Root CA generates certificates and keys for the server and for the client, this happens inside the mTLS server. The generated client files should be moved to the client, along with a copy of the root certificate. Here's a little scheme:

```
                 ┌──────────────┐
                 │  Root CA     │
                 │  (root.crt)  │
                 └──────┬───────┘
                        │
        ┌───────────────┴───────────────┐
        │                               │
┌───────▼────────┐             ┌────────▼────────┐
│ Services Caddy │             │ Raspberry Caddy │
│                │             │                 │
│ server.crt     │             │ client.crt      │
│ server.key     │             │ client.key      │
│ root.crt       │             │ root.crt        │
└────────────────┘             └─────────────────┘
```

### Issuing a server certificate

If we use `tls internal` in Caddy we will present a temporary auto-generated server cert, which is not ideal for mTLS. We need to have a fixed server certificate.

```bash
# Create a new file
cat << 'EOF' > services-server.cnf
[ req ]
distinguished_name = dn
req_extensions     = req_ext
prompt             = no

[ dn ]
CN = *.internal.glomyer.dev

[ req_ext ]
subjectAltName = DNS:*.internal.glomyer.dev

# another approach
#[ alt_names ]
#DNS.1 = dashy.internal.glomyer.dev
EOF

# Create a server CSR (Certificate Signing Request)
openssl req -new \
  -newkey ec:<(openssl ecparam -name prime256v1) \
  -nodes \
  -keyout services-server.key \
  -out services-server.csr \
  -config services-server.cnf

# Sign the client certificate using Caddy’s CA
sudo openssl x509 -req \
  -in services-server.csr \
  -CA /var/lib/caddy/.local/share/caddy/pki/authorities/local/root.crt \
  -CAkey /var/lib/caddy/.local/share/caddy/pki/authorities/local/root.key \
  -CAcreateserial \
  -out services-server.crt \
  -days 3650 \
  -extensions req_ext \
  -extfile services-server.cnf

# Verify the generated certificate
sudo openssl verify -CAfile /var/lib/caddy/.local/share/caddy/pki/authorities/local/root.crt /etc/caddy/mtls/services-server.crt
```


### Issuing a client certificate

```bash
# Create a private key for the Raspberry Pi (client)
openssl genrsa -out raspberry-client.key 4096
# Create a client CSR (Certificate Signing Request)
openssl req -new \
  -key raspberry-client.key \
  -out raspberry-client.csr \
  -subj "/CN=raspberry.edge.glomyer.dev"

# Create a client certificate extension file (mandatory)
cat << 'EOF' > client.ext
basicConstraints = CA:FALSE
keyUsage = digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth
EOF

# Sign the client certificate using Caddy’s CA
sudo openssl x509 -req \
  -in raspberry-client.csr \
  -CA /var/lib/caddy/.local/share/caddy/pki/authorities/local/root.crt \
  -CAkey /var/lib/caddy/.local/share/caddy/pki/authorities/local/root.key \
  -CAcreateserial \
  -out raspberry-client.crt \
  -days 3650 \
  -sha256 \
  -extfile client.ext

# Verify the generated certificate
sudo openssl verify -CAfile /var/lib/caddy/.local/share/caddy/pki/authorities/local/root.crt raspberry-client.crt

# Test with a request (should fail)
curl https://dashy.internal.glomyer.dev \
--resolve dashy.internal.glomyer.dev:443:192.168.0.200

# Test with a request (should succeed)
sudo curl -v https://dashy.internal.glomyer.dev \
  --resolve dashy.internal.glomyer.dev:443:192.168.0.200 \
  --cacert /etc/caddy/mtls/services-ca.crt \
  --cert /etc/caddy/mtls/raspberry-client.crt \
  --key /etc/caddy/mtls/raspberry-client.key
```


# Useful links

- https://github.com/caddyserver/caddy
- https://caddyserver.com/docs/
- https://dash.cloudflare.com/
- https://www.duckdns.org/
- https://github.com/DoTheEvo/selfhosted-apps-docker/tree/master/caddy_v2
